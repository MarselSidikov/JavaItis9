# Массивы

* Массив - структура данных, представляющая собой набор переменных, доступ к каждой из которых возможен по ее индексу.

```
Массив размера n.

[3][2][2][1] ... [99]  <- значения
 0  1  2  3  ... n - 1 <- индексы

```
## Пример использования

* Задача - вывести двоичное предсталение числа от 0 до 255.

```JAVA
int x7, x6, x5, x4, x3, x2, x1, x0; // память выделяется вразброс
```

```JAVA
int digits[] = new int[8]; // последовательно резевируется 32 байта

digits[0] = 1;
digits[1] = 0;
digits[2] = 0;
digits[3] = 1;
digits[4] = 1;
digits[5] = 0;
digits[6] = 1;
digits[7] = 1;

System.out.println(digits[0]);
System.out.println(digits[1]);
System.out.println(digits[2]);
System.out.println(digits[3]);
System.out.println(digits[4]);
...
```

### Массив в C++

```C

#include <iostream>

using namespace std;

int main()
{
    // объявляем массив
    int *a = new int[8];
    // в переменную pointerOnA сохраняем адрес массива
    int *pointerOnA = a;
    // в переменную pointerOnFirstOfA сохраняем адрес первого элемента массива
    int *pointerOnFirstOfA = &a[0];
    // в переменную pointerOnSecondOfA сохраняем адрес второго элемента массива
    int *pointerOnSecondOfA = &a[1];
    // выводим эти адреса
    cout << pointerOnA << " " << pointerOnFirstOfA << " " << pointerOnSecondOfA;
}
```

* Вывод приложения

```
0x1476c20(16)-> 21457952
0x1476c20(16)-> 21457952
0x1476c24(16)-> 21457956

Каждый новый элемент будет отступать от предыдущего на 4 байта (то есть на размер int)
```

### Получение элемента массива и хранение его в памяти

```
[2] [5] [6] [8] [1] <- значения
  0   1   2   3   4 <- индексы
122 126 130 134 138 <- адреса

a[3] = 5; // адрес(a[0]) + индекс * размер_типа = 
=> 122 + 3 * 4 = 134, следовательно в переменную, которая стоит под адресом 134 нужно положить 5. 
```

### Разворот массива на месте

```
Исходные данные:

[2] [5] [6] [8] [1] <- значения
  0   1   2   3   4 <- индексы

Результат:

[1] [8] [6] [5] [2] [3] [9] <- значения
  0   1   2   3   4   5   6  <- индексы

Решение:

a[0] <-> a[6]
a[1] <-> a[5]
a[2] <-> a[4]

Элементов всего 7. Итераций выполнено 3.
Следовательно, при N-элементов выполняется N/2 итераций.

Пусть N = 7.

a[0] <-> a[7 - 1 - 0]
a[1] <-> a[7 - 1 - 1]
a[2] <-> a[7 - 1 - 2]

Следовательно формула разворота:

a[i] <-> a[N - 1 - i]

Поменять местами две переменные:

int x = 6;
int y = 5;

int temp = x;
x = y;
y = temp;
```

### Сортировка массива

* Упорядочивание массива, то есть для любых i и j должно выполнятся отношение a[i] < a[j], i < j (порядок по возрастанию)

* Зачем сортировать? - ускоряет поиск.

### Сортировка выбором (Selection Sort)

```JAVA
[ 4] [ 2] [-3] [-5] [ 1] [ 8] [-6]
   0    1    2    3    4    5    6

Пусть x = 0, y = 6
Найдем минимальный элемент в области a[x]...a[y], то есть a[0] до a[6].

Это элемент - a[6] = -6, поместим его в начало массива.
a[x] <-> a[6] => a[0] <-> a[6], получим:

[-6] [ 2] [-3] [-5] [ 1] [ 8] [ 4]
   0    1    2    3    4    5    6

		JavaCode:
        //-------------------
		int x = 0;
		int y = N - 1;

		int min = a[x];
		int minIndex = x;

		for (int i = x; i < y; i++) {
			if (min < a[i]) {
				min = a[i];
				minIndex = i;
			}
		}

		int temp = a[x];
		a[x] = a[minIndex];
		a[minIndex] = temp;
		//-------------------

[-6] [ 2] [-3] [-5] [ 1] [ 8] [ 4]
   0    1    2    3    4    5    6

Пусть x = 1, y = 6
Найдем минимальный элемент в области a[x]...a[y], то есть a[1] до a[6].

Это элемент - a[3] = -5, поместим его во второй элемент массива.
a[x] <-> a[3] => a[1] <-> a[3], получим:

[-6] [-5] [-3] [ 2] [ 1] [ 8] [ 4]
   0    1    2    3    4    5    6

JavaCode:
        //-------------------
        ...
		x++;

		int min = a[x];
		int minIndex = x;

		for (int i = x; i < y; i++) {
			if (min < a[i]) {
				min = a[i];
				minIndex = i;
			}
		}

		temp = a[x];
		a[x] = a[minIndex];
		a[minIndex] = temp;
		//-------------------

Поскольку повторение цикла for произойдет 7 раз с различным x, то это тоже можно поместить в цикл.

Итоговое решение см. в 13. Selection Sort
```

### Стандартная 27-я задача ЕГЭ по информатике (см. Задание 5)

```
Пусть дана последовательность A = {a1, a2, ..., aN}, всего N-элементов. Предполагается, что N -> infinity, но знаем, что aN = -1.

ai это число от 0 до 999.

Выяснить, какое число встречается чаще других?
```

* Решение

```
Пусть подается следующая последовательность:

5
7
8
5
5
6
7
8
1
1
-1

Считываем 5. Сколько раз встретилась 5-ка теперь? 1 раз.
Считываем 7. Сколько раз встретилась 7-ка теперь? 1 раз.
Считываем 8. Сколько раз встретилась 8-ка теперь? 1 раз.
Считываем 5. Сколько раз встретилась 5-ка теперь? 2 раза.
Считываем 5. Сколько раз встретилась 5-ка теперь? 3 раза.
Считываем 6. Сколько раз встретилась 6-ка теперь? 1 раз.
Считываем 7. Сколько раз встретилась 7-ка теперь? 2 раза.
Считываем 8. Сколько раз встретилась 8-ка теперь? 2 раза.
Считываем 1. Сколько раз встретилась 1-ка теперь? 1 раз.
Считываем 1. Сколько раз встретилась 1-ка теперь? 2 раза.

-- PSEUDO CODE:

int a[] = new int[1000];
while (currentNumber != -1) {
	currentNumber = scanner.nextInt();
	a[currentNumber]++;
}

```

### Алгоритм бинарного поиска

```
Пусть есть отсортированная последовательность

a0 a2 a3 .... aN-1

Мы в нем ищем FOUND

left = 0
right = N - 1
middle = left + (right - left) / 2;

ПОКА a[middle] != FOUNDED: 
	Если a[middle] > FOUNDED:
		left = left
		right = middle
		middle = left + (right - left) / 2;
	Если a[middle] < FOUNDED:
		left = middle
		right = right
		middle = left + (right - left) / 2;
```