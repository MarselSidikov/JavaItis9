# Ассоциативные массивы (Map)

* Ассоциативный массив - это понятие, которое описывает некоторую таблицу <ключ>-<значение>, где ключ может быть любым типом, аналогично значение - любого типа. Ключ должен быть уникальным.

* Например, таблица имен людей, и самих людей:

```
| ключ - String | значение - Human                      |
---------------------------------------------------------
|Марсель        |{name: "Марсель", age: 25, is_man:true}|
|Надир          |{name: "Надир", age: 22, is_man:true}  |
```

* Частным примером ассоциативного массива является - обычный массив. Где ключ имеет тип int.

## Вопрос - как реализовать ассоциативный массив?

### Вариант 1

- Использование двух массивов, один хранит ключи, другой хранит значения.

Минусы: 
1) низкая скорость получение значения по ключу - необходимо найти ключ в первом массиве, чтобы понять, где хранится соответствующее значение.

2) низкая скорость добавления, если мы гарантируем уникальность ключа.

### Вариант 2

Использование одного обычного массива, у которого ключ - целое число. При этом получение значения по ключу - очень быстрое (a[5]).

Задача: преобразовать любой ключ в число (индекс массива).

Хеширование: преобразование одной последовательности бит в другую последовательность бит.

Идеальная хеш-функция - позволяет сопоставить однозначно элемент из первого множества элементу второго множества.

```
	   M                  N
{A, B, C, D, E} -> {U, W, X, Y, Z}

A <-> X
B <-> W
D <-> Z
E <-> U
C <-> Y
```

Но на практике множества M и N несоизмеримы, поэтому не бывает взаимо-однозначного сопоставления.

Например:

Любой ключ * -> любой индекс 

{A, B, C, D, ..., EE, ..... EY, ...} -> 0 ... 2 147 483 647

Следовательно, одному значению из множества N будет соответствовать несколько значений из M:

```
	   M                  N
{A, B, C, D, E} -> {X, Y, Z}

A <-> X
B <-> X
D <-> Z
E <-> Y
C <-> Y
```

Случай, когда отображение не однозначное (при хешировании) говорят о возникновении коллизии.

Задача 2: понять, какой хешкод например у строки, хеш-код в java это число int.

Если мы просто сложим все коды символов - получим очень много коллизий -> например, строки `AB` и `BA` совпадать по хеш-коду.

Чтобы минимизировать коллизии для строк, они считаются по специальной формуле: hash = SUM {s[i] * 31 ^ n - 1 - i}. Например, для `AB`:

```
code(A) * 31 ^ (2 - 1 - 0) + code(B) * 31 ^ (2 - 1 - 1) = 65 * 31 + 66 * 1 = 2081
```

* Обрезание хеш-кода

```
-985016399 -> 11000101010010011101011110110001
15 -> 1111

&
  11000101010010011101011110110001
                              1111
                              ----
                              0001
```

Суть - использовать хеш-коды для хранения в обычном массиве.
Плюсы - очень быстро кладем, очень быстро забираем.
Минусы - из-за коллизий есть высокий риск потерять данные.

## Вариант 3